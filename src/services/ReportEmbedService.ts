// src/services/ReportEmbedService.ts - Integration service for reliable report embed sending
import { ChatInputCommandInteraction } from 'discord.js';
import { injectable, inject } from 'tsyringe';

import {
  IReliableEmbedSender,
  ThreeSectionReport,
  ReportSectionData,
  EmbedSendResult,
  ReliableEmbedSendOptions
} from '../interfaces/IReliableEmbedSender.js';
import { DI_TOKENS } from '../interfaces/index.js';
import { EmbedFactory } from '../utils/embedBuilder.js';
import type { UserActivityData } from '../utils/embedBuilder';

// Date range interface for reports
interface DateRange {
  startDate: Date;
  endDate: Date;
}

// Report generation configuration
interface ReportConfiguration {
  role: string;
  dateRange: DateRange;
  minHours: number;
  reportCycle?: number | null;
  testMode?: boolean;
  enableProgressTracking?: boolean;
  maxRetries?: number;
}

// User classification result from existing service
interface UserClassificationResult {
  activeUsers: UserActivityData[];
  inactiveUsers: UserActivityData[];
  afkUsers: UserActivityData[];
  minHours: number;
  reportCycle?: string | null;
}

@injectable()
export class ReportEmbedService {
  constructor(
    @inject(DI_TOKENS.IReliableEmbedSender) 
    private readonly reliableEmbedSender: IReliableEmbedSender
  ) {}

  /**
   * Generate and send a 3-section activity report with reliability features
   */
  async generateAndSendReport(
    interaction: ChatInputCommandInteraction,
    config: ReportConfiguration,
    classificationResult: UserClassificationResult
  ): Promise<EmbedSendResult> {
    // Create the 3-section report structure
    const report = this.createThreeSectionReport(config, classificationResult);

    // Configure reliable sending options
    const sendOptions: Partial<ReliableEmbedSendOptions> = {
      maxRetries: config.maxRetries ?? 3,
      retryDelayMs: 1000,
      backoffMultiplier: 2,
      maxEmbedsPerMessage: 10,
      chunkDelayMs: 500,
      enableTextFallback: true,
      enableProgressTracking: config.enableProgressTracking ?? true,
      strictValidation: true,
      autoTruncate: true,
      reportErrors: true,
      ephemeral: config.testMode ?? false,
      textFallbackTemplate: this.createTextFallbackTemplate(config)
    };

    // Add progressCallback conditionally for exactOptionalPropertyTypes
    if (config.enableProgressTracking) {
      sendOptions.progressCallback = this.createProgressCallback(interaction);
    }

    try {
      // Send the report using the reliable embed sender
      const result = await this.reliableEmbedSender.sendThreeSectionReport(
        interaction,
        report,
        sendOptions
      );

      // Log statistics for monitoring
      this.logSendStatistics(config, result);

      return result;

    } catch (error) {
      console.error('[ReportEmbedService] Report sending failed:', error);
      
      // Return failure result
      return {
        success: false,
        messagesSent: [],
        errorMessages: [error instanceof Error ? error.message : 'Ïïå Ïàò ÏóÜÎäî Ïò§Î•ò'],
        fallbackUsed: false,
        totalEmbeds: 0,
        chunksCreated: 0,
        retryAttempts: 0,
        executionTime: 0,
        validationErrors: []
      };
    }
  }

  /**
   * Send test report with enhanced error reporting
   */
  async sendTestReport(
    interaction: ChatInputCommandInteraction,
    config: ReportConfiguration,
    classificationResult: UserClassificationResult
  ): Promise<EmbedSendResult> {
    console.log(`[ReportEmbedService] ÌÖåÏä§Ìä∏ Î≥¥Í≥†ÏÑú Ï†ÑÏÜ° ÏãúÏûë`);
    
    const testConfig = {
      ...config,
      testMode: true,
      enableProgressTracking: true,
      maxRetries: 1 // Faster failure for testing
    };

    const result = await this.generateAndSendReport(interaction, testConfig, classificationResult);

    // Add test mode footer to success message
    if (result.success && result.messagesSent.length > 0) {
      try {
        await interaction.followUp({
          content: 
            `üß™ **ÌÖåÏä§Ìä∏ Î™®Îìú ÏôÑÎ£å**\n\n` +
            `‚úÖ **Ï†ÑÏÜ° ÏÑ±Í≥µ:** ${result.success}\n` +
            `üìä **Ï†ÑÏÜ°Îêú ÏûÑÎ≤†Îìú:** ${result.totalEmbeds}Í∞ú\n` +
            `üì¶ **ÏÉùÏÑ±Îêú Ï≤≠ÌÅ¨:** ${result.chunksCreated}Í∞ú\n` +
            `üîÑ **Ïû¨ÏãúÎèÑ ÌöüÏàò:** ${result.retryAttempts}Ìöå\n` +
            `‚è±Ô∏è **Ïã§Ìñâ ÏãúÍ∞Ñ:** ${result.executionTime}ms\n` +
            `üìù **Ìè¥Î∞± ÏÇ¨Ïö©:** ${result.fallbackUsed ? 'Ïòà' : 'ÏïÑÎãàÏò§'}\n` +
            `${result.validationErrors.length > 0 ? `‚ö†Ô∏è **Í≤ÄÏ¶ù Í≤ΩÍ≥†:** ${result.validationErrors.length}Í∞ú\n` : ''}` +
            `\n*Î¶¨ÏÖã ÏãúÍ∞ÑÏù¥ Í∏∞Î°ùÎêòÏßÄ ÏïäÏïòÏäµÎãàÎã§.*`,
          flags: 64 // Ephemeral
        });
      } catch (followUpError) {
        console.warn('[ReportEmbedService] Test result follow-up failed:', followUpError);
      }
    }

    return result;
  }

  /**
   * Get service health and performance metrics
   */
  getServiceStatistics() {
    return this.reliableEmbedSender.getStatistics();
  }

  /**
   * Validate report embeds before sending
   */
  async validateReportEmbeds(
    config: ReportConfiguration,
    classificationResult: UserClassificationResult
  ) {
    const report = this.createThreeSectionReport(config, classificationResult);
    const allEmbeds = [
      ...report.achievementSection.embeds,
      ...report.underperformanceSection.embeds,
      ...(report.afkSection ? report.afkSection.embeds : [])
    ];

    return await this.reliableEmbedSender.validateEmbeds(allEmbeds);
  }

  // Private helper methods

  private createThreeSectionReport(
    config: ReportConfiguration,
    classificationResult: UserClassificationResult
  ): ThreeSectionReport {
    const reportId = this.generateReportId(config);
    
    // Prepare reportCycle for exactOptionalPropertyTypes
    const reportCycle = config.reportCycle ?? null;

    // Create achievement section (Îã¨ÏÑ±)
    const achievementEmbeds = EmbedFactory.createActivityEmbeds({
      role: config.role,
      activeUsers: classificationResult.activeUsers,
      inactiveUsers: [], // Only active users in achievement section
      afkUsers: [],
      startDate: config.dateRange.startDate,
      endDate: config.dateRange.endDate,
      minHours: config.minHours,
      reportCycle,
      title: 'ÌôúÎèô Îã¨ÏÑ± Î≥¥Í≥†ÏÑú'
    }).slice(0, 1); // Only take the active users embed

    // Create underperformance section (ÎØ∏Îã¨ÏÑ±)
    const underperformanceEmbeds = EmbedFactory.createActivityEmbeds({
      role: config.role,
      activeUsers: [], // Only inactive users in underperformance section
      inactiveUsers: classificationResult.inactiveUsers,
      afkUsers: [],
      startDate: config.dateRange.startDate,
      endDate: config.dateRange.endDate,
      minHours: config.minHours,
      reportCycle,
      title: 'ÌôúÎèô ÎØ∏Îã¨ÏÑ± Î≥¥Í≥†ÏÑú'
    }).slice(1, 2); // Only take the inactive users embed

    // Create AFK section if needed (Ïû†Ïàò)
    let afkSection: ReportSectionData | undefined;
    if (classificationResult.afkUsers.length > 0) {
      const afkEmbeds = EmbedFactory.createActivityEmbeds({
        role: config.role,
        activeUsers: [],
        inactiveUsers: [],
        afkUsers: classificationResult.afkUsers,
        startDate: config.dateRange.startDate,
        endDate: config.dateRange.endDate,
        minHours: config.minHours,
        reportCycle,
        title: 'Ïû†Ïàò ÏÉÅÌÉú Î≥¥Í≥†ÏÑú'
      }).slice(2); // Take the AFK embed(s)

      afkSection = {
        title: 'Ïû†Ïàò ÏÉÅÌÉú Î©§Î≤Ñ',
        embeds: afkEmbeds,
        sectionType: 'afk',
        priority: 'low'
      };
    }

    const result: ThreeSectionReport = {
      achievementSection: {
        title: 'ÌôúÎèô Í∏∞Ï§Ä Îã¨ÏÑ± Î©§Î≤Ñ',
        embeds: achievementEmbeds,
        sectionType: 'achievement',
        priority: 'high'
      },
      underperformanceSection: {
        title: 'ÌôúÎèô Í∏∞Ï§Ä ÎØ∏Îã¨ÏÑ± Î©§Î≤Ñ',
        embeds: underperformanceEmbeds,
        sectionType: 'underperformance',
        priority: 'medium'
      },
      metadata: {
        reportId,
        generatedAt: new Date(),
        totalMembers: classificationResult.activeUsers.length + 
                     classificationResult.inactiveUsers.length + 
                     classificationResult.afkUsers.length,
        dateRange: {
          start: config.dateRange.startDate,
          end: config.dateRange.endDate
        }
      }
    };

    // Add afkSection conditionally for exactOptionalPropertyTypes
    if (afkSection) {
      result.afkSection = afkSection;
    }

    return result;
  }

  private createTextFallbackTemplate(config: ReportConfiguration): string {
    return `‚ö†Ô∏è **ÏûÑÎ≤†Îìú Ï†ÑÏÜ° Ïã§Ìå® - ÌÖçÏä§Ìä∏ ÌòïÏãùÏúºÎ°ú Ï†ÑÌôò**\n\n` +
           `üìä **${config.role} Ïó≠Ìï† ÌôúÎèô Î≥¥Í≥†ÏÑú**\n` +
           `üìÖ **Í∏∞Í∞Ñ:** ${config.dateRange.startDate.toLocaleDateString('ko-KR')} ~ ${config.dateRange.endDate.toLocaleDateString('ko-KR')}\n` +
           `‚è∞ **ÏµúÏÜå ÌôúÎèô ÏãúÍ∞Ñ:** ${config.minHours}ÏãúÍ∞Ñ\n\n` +
           `{content}`;
  }

  private createProgressCallback(interaction: ChatInputCommandInteraction) {
    let lastUpdateTime = 0;
    const updateThreshold = 2000; // Update every 2 seconds minimum

    return async (progress: any) => {
      const now = Date.now();
      if (now - lastUpdateTime < updateThreshold) return;
      lastUpdateTime = now;

      const progressPercentage = progress.totalChunks > 0 
        ? Math.round((progress.currentChunk / progress.totalChunks) * 100)
        : 0;

      const progressBar = this.createProgressBar(progressPercentage);

      try {
        // Only send progress updates for long-running operations
        if (progress.stage === 'sending' && progress.totalChunks > 2) {
          await interaction.followUp({
            content: 
              `üìä **Î≥¥Í≥†ÏÑú Ï†ÑÏÜ° ÏßÑÌñâÏÉÅÌô©**\n\n` +
              `${progressBar} ${progressPercentage}%\n` +
              `üì¶ **ÏßÑÌñâÏÉÅÌô©:** ${progress.currentChunk}/${progress.totalChunks} Ï≤≠ÌÅ¨\n` +
              `üìã **Îã®Í≥Ñ:** ${this.translateProgressStage(progress.stage)}\n` +
              `üí¨ **ÏÉÅÌÉú:** ${progress.message}`,
            flags: 64 // Ephemeral
          });
        }
      } catch (error) {
        console.warn('[ReportEmbedService] Progress update failed:', error);
      }
    };
  }

  private createProgressBar(percentage: number): string {
    const filledLength = Math.round(percentage / 10);
    const emptyLength = 10 - filledLength;
    return 'üü©'.repeat(filledLength) + '‚¨ú'.repeat(emptyLength);
  }

  private translateProgressStage(stage: string): string {
    switch (stage) {
      case 'validation': return 'Í≤ÄÏ¶ù Ï§ë';
      case 'chunking': return 'Ï≤≠ÌÅ¨ ÏÉùÏÑ±';
      case 'sending': return 'Ï†ÑÏÜ° Ï§ë';
      case 'retry': return 'Ïû¨ÏãúÎèÑ Ï§ë';
      case 'fallback': return 'Ìè¥Î∞± Ï≤òÎ¶¨';
      case 'completed': return 'ÏôÑÎ£å';
      case 'failed': return 'Ïã§Ìå®';
      default: return stage;
    }
  }

  private generateReportId(config: ReportConfiguration): string {
    const timestamp = Date.now().toString(36);
    const roleHash = config.role.replace(/[^a-zA-Z0-9]/g, '').substring(0, 4);
    const dateHash = config.dateRange.startDate.getTime().toString(36).substring(-4);
    return `RPT_${roleHash}_${dateHash}_${timestamp}`.toUpperCase();
  }

  private logSendStatistics(config: ReportConfiguration, result: EmbedSendResult): void {
    const stats = this.reliableEmbedSender.getStatistics();
    
    console.log(`[ReportEmbedService] Î≥¥Í≥†ÏÑú Ï†ÑÏÜ° ÌÜµÍ≥Ñ:`);
    console.log(`  - Ïó≠Ìï†: ${config.role}`);
    console.log(`  - ÏÑ±Í≥µ: ${result.success}`);
    console.log(`  - Ï†ÑÏÜ°Îêú ÏûÑÎ≤†Îìú: ${result.totalEmbeds}Í∞ú`);
    console.log(`  - Ï≤≠ÌÅ¨ Ïàò: ${result.chunksCreated}Í∞ú`);
    console.log(`  - Ïû¨ÏãúÎèÑ ÌöüÏàò: ${result.retryAttempts}Ìöå`);
    console.log(`  - Ïã§Ìñâ ÏãúÍ∞Ñ: ${result.executionTime}ms`);
    console.log(`  - Ìè¥Î∞± ÏÇ¨Ïö©: ${result.fallbackUsed}`);
    console.log(`  - ÏÑúÎπÑÏä§ ÏÑ±Í≥µÎ•†: ${stats.successRate}%`);
    console.log(`  - ÏÑúÎπÑÏä§ ÌèâÍ∑† Ïû¨ÏãúÎèÑ: ${stats.averageRetries}Ìöå`);
    console.log(`  - Ìè¥Î∞± ÏÇ¨Ïö©Î•†: ${stats.fallbackUsageRate}%`);
  }
}
// src/services/DiscordStreamingService.ts - Discord Integration for Streaming Reports

import { 
  ChatInputCommandInteraction, 
  EmbedBuilder, 
  MessageFlags,
  ActionRowBuilder,
  ButtonBuilder,
  ButtonStyle,
  ComponentType,
  InteractionResponse,
  Message
} from 'discord.js';
import { injectable } from 'tsyringe';

import type {
  StreamingProgress,
  PartialReportResult,
  StreamingReportResult,
  StreamingError,
  DiscordStreamingOptions,
  StreamingStage,
  DEFAULT_DISCORD_OPTIONS
} from '../interfaces/IStreamingReportEngine';

/**
 * Progress message context for managing Discord updates
 */
interface ProgressMessageContext {
  messageId?: string;
  lastUpdate: number;
  updateCount: number;
  embedHistory: EmbedBuilder[];
  progressMessage?: Message | InteractionResponse;
}

/**
 * Discord streaming service for real-time report updates
 */
@injectable()
export class DiscordStreamingService {
  private messageContexts = new Map<string, ProgressMessageContext>();
  private readonly MAX_EMBED_HISTORY = 3;
  private readonly MAX_UPDATE_FREQUENCY = 1000; // 1 second minimum between updates

  /**
   * Initialize streaming session with Discord
   */
  async initializeStreamingSession(
    interaction: ChatInputCommandInteraction,
    operationId: string,
    options: DiscordStreamingOptions
  ): Promise<void> {
    const context: ProgressMessageContext = {
      lastUpdate: 0,
      updateCount: 0,
      embedHistory: []
    };

    this.messageContexts.set(operationId, context);

    // Send initial progress message
    const initialEmbed = this.createProgressEmbed(
      {
        current: 0,
        total: 100,
        percentage: 0,
        message: 'üöÄ Ïä§Ìä∏Î¶¨Î∞ç Î≥¥Í≥†ÏÑú ÏÉùÏÑ±ÏùÑ ÏãúÏûëÌï©ÎãàÎã§...',
        stage: 'initializing' as StreamingStage,
        itemsProcessed: 0,
        processingRate: 0
      },
      options
    );

    const components = this.createProgressComponents(operationId, false);

    try {
      if (interaction.deferred || interaction.replied) {
        const response = await interaction.followUp({
          embeds: [initialEmbed],
          components: [components],
          flags: options.ephemeral ? MessageFlags.Ephemeral : undefined
        });
        
        if ('id' in response) {
          context.messageId = response.id;
          context.progressMessage = response;
        }
      } else {
        const response = await interaction.reply({
          embeds: [initialEmbed],
          components: [components],
          flags: options.ephemeral ? MessageFlags.Ephemeral : undefined
        });
        
        context.progressMessage = response;
      }

      console.log(`[DiscordStreaming] Initialized session for operation: ${operationId}`);
    } catch (error) {
      console.error(`[DiscordStreaming] Failed to initialize session:`, error);
      throw error;
    }
  }

  /**
   * Update progress in Discord
   */
  async updateProgress(
    operationId: string,
    progress: StreamingProgress,
    options: DiscordStreamingOptions
  ): Promise<void> {
    const context = this.messageContexts.get(operationId);
    if (!context) {
      console.warn(`[DiscordStreaming] No context found for operation: ${operationId}`);
      return;
    }

    const now = Date.now();
    
    // Rate limiting: don't update too frequently
    if (now - context.lastUpdate < Math.max(options.updateThrottle, this.MAX_UPDATE_FREQUENCY)) {
      return;
    }

    try {
      const progressEmbed = this.createProgressEmbed(progress, options);
      const components = this.createProgressComponents(operationId, progress.stage === 'completed');

      // Update the message
      if (context.progressMessage && 'edit' in context.progressMessage) {
        await context.progressMessage.edit({
          embeds: [progressEmbed],
          components: [components]
        });
      }

      // Add to embed history
      context.embedHistory.push(progressEmbed);
      if (context.embedHistory.length > this.MAX_EMBED_HISTORY) {
        context.embedHistory.shift();
      }

      context.lastUpdate = now;
      context.updateCount++;

      console.log(`[DiscordStreaming] Updated progress for ${operationId}: ${progress.percentage}%`);

    } catch (error) {
      console.error(`[DiscordStreaming] Failed to update progress:`, error);
      // Don't throw - streaming should continue even if updates fail
    }
  }

  /**
   * Send partial results
   */
  async sendPartialResult(
    operationId: string,
    partialResult: PartialReportResult,
    options: DiscordStreamingOptions
  ): Promise<void> {
    const context = this.messageContexts.get(operationId);
    if (!context?.progressMessage) {
      console.warn(`[DiscordStreaming] No context for partial result: ${operationId}`);
      return;
    }

    try {
      // Create partial result embed
      const partialEmbed = this.createPartialResultEmbed(partialResult, options);
      
      // Send partial results as a follow-up message
      if ('followUp' in context.progressMessage) {
        await context.progressMessage.followUp({
          embeds: [partialEmbed, ...(partialResult.embeds || []).slice(0, 3)], // Limit embeds
          flags: options.ephemeral ? MessageFlags.Ephemeral : undefined
        });
      }

      console.log(`[DiscordStreaming] Sent partial result for ${operationId}: batch ${partialResult.batchInfo?.batchNumber}`);

    } catch (error) {
      console.error(`[DiscordStreaming] Failed to send partial result:`, error);
    }
  }

  /**
   * Send final results
   */
  async sendFinalResult(
    operationId: string,
    result: StreamingReportResult,
    options: DiscordStreamingOptions
  ): Promise<void> {
    const context = this.messageContexts.get(operationId);
    if (!context?.progressMessage) {
      console.warn(`[DiscordStreaming] No context for final result: ${operationId}`);
      return;
    }

    try {
      // Create completion embed
      const completionEmbed = this.createCompletionEmbed(result, options);
      
      // Update progress message with completion status
      if ('edit' in context.progressMessage) {
        await context.progressMessage.edit({
          embeds: [completionEmbed],
          components: [this.createProgressComponents(operationId, true)]
        });
      }

      // Send final results
      if ('followUp' in context.progressMessage) {
        // Split embeds into chunks to avoid Discord limits
        const embedChunks = this.chunkEmbeds(result.embeds, options.maxEmbedsPerMessage);
        
        for (let i = 0; i < embedChunks.length; i++) {
          const chunk = embedChunks[i];
          const isLast = i === embedChunks.length - 1;
          
          await context.progressMessage.followUp({
            content: i === 0 ? 'üìä **ÏµúÏ¢Ö Î≥¥Í≥†ÏÑú Í≤∞Í≥º**' : undefined,
            embeds: chunk,
            flags: options.ephemeral ? MessageFlags.Ephemeral : undefined,
            ...(isLast && {
              components: [this.createFinalResultComponents(result)]
            })
          });

          // Small delay between chunks
          if (!isLast) {
            await this.sleep(500);
          }
        }
      }

      console.log(`[DiscordStreaming] Sent final result for ${operationId}`);

    } catch (error) {
      console.error(`[DiscordStreaming] Failed to send final result:`, error);
    } finally {
      // Clean up context
      this.cleanupContext(operationId);
    }
  }

  /**
   * Handle streaming errors
   */
  async handleStreamingError(
    operationId: string,
    error: StreamingError,
    options: DiscordStreamingOptions
  ): Promise<void> {
    const context = this.messageContexts.get(operationId);
    if (!context?.progressMessage) {
      console.warn(`[DiscordStreaming] No context for error: ${operationId}`);
      return;
    }

    try {
      const errorEmbed = this.createErrorEmbed(error, options);

      // Update progress message with error
      if ('edit' in context.progressMessage) {
        await context.progressMessage.edit({
          embeds: [errorEmbed],
          components: [this.createProgressComponents(operationId, true, true)]
        });
      }

      console.log(`[DiscordStreaming] Handled error for ${operationId}: ${error.code}`);

    } catch (updateError) {
      console.error(`[DiscordStreaming] Failed to handle streaming error:`, updateError);
    } finally {
      // Clean up context
      this.cleanupContext(operationId);
    }
  }

  /**
   * Handle operation cancellation
   */
  async handleCancellation(
    operationId: string,
    options: DiscordStreamingOptions
  ): Promise<void> {
    const context = this.messageContexts.get(operationId);
    if (!context?.progressMessage) {
      return;
    }

    try {
      const cancelEmbed = new EmbedBuilder()
        .setTitle('‚èπÔ∏è ÏûëÏóÖ Ï∑®ÏÜåÎê®')
        .setDescription('Ïä§Ìä∏Î¶¨Î∞ç Î≥¥Í≥†ÏÑú ÏÉùÏÑ±Ïù¥ ÏÇ¨Ïö©ÏûêÏóê ÏùòÌï¥ Ï∑®ÏÜåÎêòÏóàÏäµÎãàÎã§.')
        .setColor(0x808080)
        .setTimestamp()
        .setFooter({ text: 'Ï∑®ÏÜåÎêú ÏûëÏóÖ' });

      if ('edit' in context.progressMessage) {
        await context.progressMessage.edit({
          embeds: [cancelEmbed],
          components: []
        });
      }

      console.log(`[DiscordStreaming] Handled cancellation for ${operationId}`);

    } catch (error) {
      console.error(`[DiscordStreaming] Failed to handle cancellation:`, error);
    } finally {
      this.cleanupContext(operationId);
    }
  }

  /**
   * Create progress embed
   */
  private createProgressEmbed(
    progress: StreamingProgress,
    options: DiscordStreamingOptions
  ): EmbedBuilder {
    const template = { ...DEFAULT_DISCORD_OPTIONS.progressTemplate, ...options.progressTemplate };
    
    // Create progress bar
    const progressBar = this.createProgressBar(progress.percentage);
    
    // Format processing rate
    const rateText = progress.processingRate 
      ? `${progress.processingRate.toFixed(1)} Ìï≠Î™©/Ï¥à`
      : 'Í≥ÑÏÇ∞ Ï§ë...';

    // Format ETA
    const etaText = progress.estimatedTimeRemaining
      ? this.formatDuration(progress.estimatedTimeRemaining)
      : 'Ïïå Ïàò ÏóÜÏùå';

    const embed = new EmbedBuilder()
      .setTitle(template?.title || 'üìä Î≥¥Í≥†ÏÑú ÏÉùÏÑ± Ï§ë...')
      .setColor(template?.color || 0x00AE86)
      .setDescription(
        `${progress.message}\n\n` +
        `${progressBar} **${progress.percentage}%**\n\n` +
        `**ÏßÑÌñâÏÉÅÌô©:** ${progress.current}/${progress.total}\n` +
        `**Ï≤òÎ¶¨Îêú Ìï≠Î™©:** ${progress.itemsProcessed || 0}Í∞ú\n` +
        `**Ï≤òÎ¶¨ ÏÜçÎèÑ:** ${rateText}\n` +
        `**ÏòàÏÉÅ ÎÇ®ÏùÄ ÏãúÍ∞Ñ:** ${etaText}\n` +
        `**ÌòÑÏû¨ Îã®Í≥Ñ:** ${this.getStageDisplayName(progress.stage)}`
      )
      .setTimestamp()
      .setFooter({ 
        text: template?.footer || 'Ïã§ÏãúÍ∞Ñ ÏóÖÎç∞Ïù¥Ìä∏ ‚Ä¢ Ïñ∏Ï†úÎì†ÏßÄ Ï∑®ÏÜåÌï† Ïàò ÏûàÏäµÎãàÎã§' 
      });

    return embed;
  }

  /**
   * Create partial result embed
   */
  private createPartialResultEmbed(
    partialResult: PartialReportResult,
    options: DiscordStreamingOptions
  ): EmbedBuilder {
    const batchInfo = partialResult.batchInfo;
    const stats = partialResult.statistics;

    const embed = new EmbedBuilder()
      .setTitle(`üìã Î∂ÄÎ∂Ñ Í≤∞Í≥º (Î∞∞Ïπò ${batchInfo?.batchNumber}/${batchInfo?.totalBatches})`)
      .setColor(0x3498db)
      .setDescription(
        `ÌòÑÏû¨ÍπåÏßÄ Ï≤òÎ¶¨Îêú Í≤∞Í≥ºÏûÖÎãàÎã§.\n\n` +
        `**Ï≤òÎ¶¨Îêú Î©§Î≤Ñ:** ${stats?.totalMembers || 0}Î™Ö\n` +
        `**ÌôúÏÑ± Î©§Î≤Ñ:** ${stats?.activeMembers || 0}Î™Ö\n` +
        `**ÎπÑÌôúÏÑ± Î©§Î≤Ñ:** ${stats?.inactiveMembers || 0}Î™Ö\n` +
        `**AFK Î©§Î≤Ñ:** ${stats?.afkMembers || 0}Î™Ö\n\n` +
        `*ÏµúÏ¢Ö Í≤∞Í≥ºÎäî Î™®Îì† Î∞∞Ïπò Ï≤òÎ¶¨ ÌõÑ Ï†úÍ≥µÎê©ÎãàÎã§.*`
      )
      .setTimestamp(partialResult.timestamp)
      .setFooter({ text: `Î∂ÄÎ∂Ñ Í≤∞Í≥º ID: ${partialResult.id}` });

    return embed;
  }

  /**
   * Create completion embed
   */
  private createCompletionEmbed(
    result: StreamingReportResult,
    options: DiscordStreamingOptions
  ): EmbedBuilder {
    const stats = result.statistics;
    const metadata = result.metadata;

    const embed = new EmbedBuilder()
      .setTitle(result.success ? '‚úÖ Î≥¥Í≥†ÏÑú ÏÉùÏÑ± ÏôÑÎ£å!' : '‚ùå Î≥¥Í≥†ÏÑú ÏÉùÏÑ± Ïã§Ìå®')
      .setColor(result.success ? 0x00FF00 : 0xFF0000)
      .setDescription(
        result.success 
          ? `Ïä§Ìä∏Î¶¨Î∞ç Î≥¥Í≥†ÏÑúÍ∞Ä ÏÑ±Í≥µÏ†ÅÏúºÎ°ú ÏÉùÏÑ±ÎêòÏóàÏäµÎãàÎã§.\n\n` +
            `**Ï¥ù Î©§Î≤Ñ:** ${stats.totalMembers}Î™Ö\n` +
            `**ÌôúÏÑ± Î©§Î≤Ñ:** ${stats.activeMembers}Î™Ö\n` +
            `**ÎπÑÌôúÏÑ± Î©§Î≤Ñ:** ${stats.inactiveMembers}Î™Ö\n` +
            `**AFK Î©§Î≤Ñ:** ${stats.afkMembers}Î™Ö\n\n` +
            `**Ï≤òÎ¶¨ ÏãúÍ∞Ñ:** ${this.formatDuration(stats.processingTime)}\n` +
            `**Ï≤òÎ¶¨Îêú Î∞∞Ïπò:** ${stats.batchesProcessed}Í∞ú\n` +
            `**Î≥µÍµ¨Îêú Ïò§Î•ò:** ${stats.errorsRecovered}Í∞ú\n` +
            `**ÏµúÎåÄ Î©îÎ™®Î¶¨ ÏÇ¨Ïö©Îüâ:** ${Math.round(stats.memoryPeak / 1024 / 1024)}MB`
          : `Î≥¥Í≥†ÏÑú ÏÉùÏÑ± Ï§ë Ïò§Î•òÍ∞Ä Î∞úÏÉùÌñàÏäµÎãàÎã§.\n\n` +
            `**Ïò§Î•ò:** ${result.error?.message || 'Ïïå Ïàò ÏóÜÎäî Ïò§Î•ò'}\n` +
            `**Îã®Í≥Ñ:** ${this.getStageDisplayName(result.error?.stage || 'error')}`
      )
      .setTimestamp()
      .setFooter({ 
        text: `ÏûëÏóÖ ID: ${result.operationId} ‚Ä¢ Ïó≠Ìï†: ${metadata.role}` 
      });

    return embed;
  }

  /**
   * Create error embed
   */
  private createErrorEmbed(
    error: StreamingError,
    options: DiscordStreamingOptions
  ): EmbedBuilder {
    const embed = new EmbedBuilder()
      .setTitle('‚ùå Ïä§Ìä∏Î¶¨Î∞ç Ïò§Î•ò Î∞úÏÉù')
      .setColor(0xFF0000)
      .setDescription(
        `Î≥¥Í≥†ÏÑú ÏÉùÏÑ± Ï§ë Ïò§Î•òÍ∞Ä Î∞úÏÉùÌñàÏäµÎãàÎã§.\n\n` +
        `**Ïò§Î•ò ÏΩîÎìú:** ${error.code}\n` +
        `**Î©îÏãúÏßÄ:** ${error.message}\n` +
        `**Îã®Í≥Ñ:** ${this.getStageDisplayName(error.stage)}\n` +
        `**Î≥µÍµ¨ Í∞ÄÎä•:** ${error.recoverable ? 'Ïòà' : 'ÏïÑÎãàÏò§'}\n` +
        `**Ïû¨ÏãúÎèÑ ÌöüÏàò:** ${error.retryCount || 0}Ìöå`
      )
      .setTimestamp(error.timestamp)
      .setFooter({ text: 'Í¥ÄÎ¶¨ÏûêÏóêÍ≤å Î¨∏ÏùòÌïòÏÑ∏Ïöî' });

    return embed;
  }

  /**
   * Create progress action buttons
   */
  private createProgressComponents(
    operationId: string,
    isCompleted: boolean,
    hasError = false
  ): ActionRowBuilder<ButtonBuilder> {
    const row = new ActionRowBuilder<ButtonBuilder>();

    if (!isCompleted && !hasError) {
      row.addComponents(
        new ButtonBuilder()
          .setCustomId(`streaming-cancel-${operationId}`)
          .setLabel('Ï∑®ÏÜå')
          .setStyle(ButtonStyle.Danger)
          .setEmoji('‚èπÔ∏è'),
        
        new ButtonBuilder()
          .setCustomId(`streaming-status-${operationId}`)
          .setLabel('ÏÉÅÌÉú ÌôïÏù∏')
          .setStyle(ButtonStyle.Secondary)
          .setEmoji('üìä')
      );
    } else if (isCompleted && !hasError) {
      row.addComponents(
        new ButtonBuilder()
          .setCustomId(`streaming-completed-${operationId}`)
          .setLabel('ÏôÑÎ£åÎê®')
          .setStyle(ButtonStyle.Success)
          .setEmoji('‚úÖ')
          .setDisabled(true)
      );
    } else if (hasError) {
      row.addComponents(
        new ButtonBuilder()
          .setCustomId(`streaming-error-${operationId}`)
          .setLabel('Ïò§Î•ò Î∞úÏÉù')
          .setStyle(ButtonStyle.Danger)
          .setEmoji('‚ùå')
          .setDisabled(true)
      );
    }

    return row;
  }

  /**
   * Create final result action buttons
   */
  private createFinalResultComponents(result: StreamingReportResult): ActionRowBuilder<ButtonBuilder> {
    const row = new ActionRowBuilder<ButtonBuilder>();

    row.addComponents(
      new ButtonBuilder()
        .setCustomId(`report-export-${result.operationId}`)
        .setLabel('ÎÇ¥Î≥¥ÎÇ¥Í∏∞')
        .setStyle(ButtonStyle.Primary)
        .setEmoji('üíæ'),
      
      new ButtonBuilder()
        .setCustomId(`report-share-${result.operationId}`)
        .setLabel('Í≥µÏú†')
        .setStyle(ButtonStyle.Secondary)
        .setEmoji('üîó')
    );

    return row;
  }

  /**
   * Create progress bar visual
   */
  private createProgressBar(percentage: number): string {
    const totalBars = 20;
    const filledBars = Math.round((percentage / 100) * totalBars);
    const emptyBars = totalBars - filledBars;
    
    const filled = '‚ñà'.repeat(filledBars);
    const empty = '‚ñë'.repeat(emptyBars);
    
    return `\`${filled}${empty}\``;
  }

  /**
   * Get display name for streaming stage
   */
  private getStageDisplayName(stage: StreamingStage | string): string {
    const stageNames: Record<string, string> = {
      'initializing': 'Ï¥àÍ∏∞Ìôî Ï§ë',
      'fetching_members': 'Î©§Î≤Ñ Ï†ïÎ≥¥ ÏàòÏßë',
      'processing_data': 'Îç∞Ïù¥ÌÑ∞ Ï≤òÎ¶¨ Ï§ë',
      'generating_partial': 'Î∂ÄÎ∂Ñ Í≤∞Í≥º ÏÉùÏÑ±',
      'streaming_results': 'Í≤∞Í≥º Ïä§Ìä∏Î¶¨Î∞ç',
      'finalizing': 'ÏµúÏ¢Ö Ï≤òÎ¶¨',
      'completed': 'ÏôÑÎ£åÎê®',
      'error': 'Ïò§Î•ò Î∞úÏÉù'
    };

    return stageNames[stage] || stage;
  }

  /**
   * Format duration in milliseconds to readable string
   */
  private formatDuration(ms: number): string {
    const seconds = Math.floor(ms / 1000);
    const minutes = Math.floor(seconds / 60);
    const remainingSeconds = seconds % 60;

    if (minutes > 0) {
      return `${minutes}Î∂Ñ ${remainingSeconds}Ï¥à`;
    } else {
      return `${remainingSeconds}Ï¥à`;
    }
  }

  /**
   * Chunk embeds for Discord message limits
   */
  private chunkEmbeds(embeds: EmbedBuilder[], maxPerChunk: number): EmbedBuilder[][] {
    const chunks: EmbedBuilder[][] = [];
    
    for (let i = 0; i < embeds.length; i += maxPerChunk) {
      chunks.push(embeds.slice(i, i + maxPerChunk));
    }
    
    return chunks;
  }

  /**
   * Clean up message context
   */
  private cleanupContext(operationId: string): void {
    this.messageContexts.delete(operationId);
    console.log(`[DiscordStreaming] Cleaned up context for: ${operationId}`);
  }

  /**
   * Sleep utility
   */
  private sleep(ms: number): Promise<void> {
    return new Promise(resolve => setTimeout(resolve, ms));
  }
}